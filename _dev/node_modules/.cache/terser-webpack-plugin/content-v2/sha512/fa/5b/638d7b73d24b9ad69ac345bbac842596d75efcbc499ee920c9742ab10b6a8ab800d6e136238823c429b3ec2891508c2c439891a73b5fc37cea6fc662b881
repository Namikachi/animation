{"code":"!function(n){var i={};function o(l){if(i[l])return i[l].exports;var t=i[l]={i:l,l:!1,exports:{}};return n[l].call(t.exports,t,t.exports,o),t.l=!0,t.exports}o.m=n,o.c=i,o.d=function(n,i,l){o.o(n,i)||Object.defineProperty(n,i,{enumerable:!0,get:l})},o.r=function(n){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(n,\"__esModule\",{value:!0})},o.t=function(n,i){if(1&i&&(n=o(n)),8&i)return n;if(4&i&&\"object\"==typeof n&&n&&n.__esModule)return n;var l=Object.create(null);if(o.r(l),Object.defineProperty(l,\"default\",{enumerable:!0,value:n}),2&i&&\"string\"!=typeof n)for(var t in n)o.d(l,t,function(i){return n[i]}.bind(null,t));return l},o.n=function(n){var i=n&&n.__esModule?function(){return n.default}:function(){return n};return o.d(i,\"a\",i),i},o.o=function(n,i){return Object.prototype.hasOwnProperty.call(n,i)},o.p=\"\",o(o.s=\"./js/bounce.js\")}({\"./js/bounce.js\":\n/*!**********************!*\\\n  !*** ./js/bounce.js ***!\n  \\**********************/\n/*! no static exports found */function(module,exports){eval('function _readOnlyError(name) { throw new Error(\"\\\\\"\" + name + \"\\\\\" is read-only\"); }\\n\\n$(function () {\\n  setup();\\n\\n  function Ball(x, y, radius, e, mass, colour) {\\n    this.position = {\\n      x: x,\\n      y: y\\n    }; //m\\n\\n    this.velocity = {\\n      x: 0,\\n      y: 0\\n    }; // m/s\\n\\n    this.e = -e; // has no units\\n\\n    this.mass = mass; //kg\\n\\n    this.radius = radius; //m\\n\\n    this.colour = colour;\\n    this.area = Math.PI * radius * radius / 10000; //m^2\\n  }\\n\\n  var canvas = null;\\n  var ctx = null;\\n  var fps = 1 / 60; //60 FPS\\n\\n  var dt = fps * 1000; //ms \\n\\n  var timer = false;\\n  var Cd = 0.47;\\n  var rho = 1.22; //kg/m^3 \\n\\n  var mouse = {\\n    x: 0,\\n    y: 0,\\n    isDown: false\\n  };\\n  var ag = 9.81; //m/s^2 acceleration due to gravity on earth = 9.81 m/s^2. \\n\\n  var width = 0;\\n  var height = 0;\\n  var balls = [];\\n\\n  var setup = function setup() {\\n    canvas = (_readOnlyError(\"canvas\"), document.getElementById(\\'canvas\\'));\\n    ctx = (_readOnlyError(\"ctx\"), canvas.getContext(\\'2d\\'));\\n    width = (_readOnlyError(\"width\"), canvas.width);\\n    height = (_readOnlyError(\"height\"), canvas.height);\\n    canvas.onmousedown = mouseDown;\\n    canvas.onmouseup = mouseUp;\\n    canvas.onmousemove = getMousePosition;\\n    timer = (_readOnlyError(\"timer\"), setInterval(loop, dt));\\n  };\\n\\n  var mouseDown = function mouseDown(e) {\\n    if (e.which == 1) {\\n      getMousePosition(e);\\n      mouse.isDown = true;\\n      var max = 255;\\n      var min = 20;\\n      var r = 75 + Math.floor(Math.random() * (max - min) - min);\\n      var g = 75 + Math.floor(Math.random() * (max - min) - min);\\n      var b = 75 + Math.floor(Math.random() * (max - min) - min);\\n      balls.push(new Ball(mouse.x, mouse.y, 10, 0.7, 10, \"rgb(\" + r + \",\" + g + \",\" + b + \")\"));\\n    }\\n  };\\n\\n  var mouseUp = function mouseUp(e) {\\n    if (e.which == 1) {\\n      mouse.isDown = false;\\n      balls[balls.length - 1].velocity.x = (balls[balls.length - 1].position.x - mouse.x) / 10;\\n      balls[balls.length - 1].velocity.y = (balls[balls.length - 1].position.y - mouse.y) / 10;\\n    }\\n  };\\n\\n  function getMousePosition(e) {\\n    mouse.x = e.pageX - canvas.offsetLeft;\\n    mouse.y = e.pageY - canvas.offsetTop;\\n  }\\n\\n  function loop() {\\n    //create constants\\n    var gravity = document.getElementById(\"gravity\");\\n    var density = document.getElementById(\"density\");\\n    var drag = document.getElementById(\"drag\"); //Clear window at the begining of every frame\\n\\n    ctx.clearRect(0, 0, width, height);\\n\\n    for (var i = 0; i < balls.length; _readOnlyError(\"i\"), i++) {\\n      if (!mouse.isDown || i != balls.length - 1) {\\n        //physics - calculating the aerodynamic forces to drag\\n        // -0.5 * Cd * A * v^2 * rho\\n        var fx = -0.5 * drag.value * density.value * balls[i].area * balls[i].velocity.x * balls[i].velocity.x * (balls[i].velocity.x / Math.abs(balls[i].velocity.x));\\n        var fy = -0.5 * drag.value * density.value * balls[i].area * balls[i].velocity.y * balls[i].velocity.y * (balls[i].velocity.y / Math.abs(balls[i].velocity.y));\\n        fx = (_readOnlyError(\"fx\"), isNaN(fx) ? 0 : fx);\\n        fy = (_readOnlyError(\"fy\"), isNaN(fy) ? 0 : fy);\\n        console.log(fx); //Calculating the accleration of the ball\\n        //F = ma or a = F/m\\n\\n        var ax = fx / balls[i].mass;\\n        var ay = ag * gravity.value + fy / balls[i].mass; //Calculating the ball velocity \\n\\n        balls[i].velocity.x += ax * fps;\\n        balls[i].velocity.y += ay * fps; //Calculating the position of the ball\\n\\n        balls[i].position.x += balls[i].velocity.x * fps * 100;\\n        balls[i].position.y += balls[i].velocity.y * fps * 100;\\n      } //Rendering the ball\\n\\n\\n      ctx.beginPath();\\n      ctx.fillStyle = balls[i].colour;\\n      ctx.arc(balls[i].position.x, balls[i].position.y, balls[i].radius, 0, 2 * Math.PI, true);\\n      ctx.fill();\\n      ctx.closePath();\\n\\n      if (mouse.isDown) {\\n        ctx.beginPath();\\n        ctx.strokeStyle = \"rgb(0,255,0)\";\\n        ctx.moveTo(balls[balls.length - 1].position.x, balls[balls.length - 1].position.y);\\n        ctx.lineTo(mouse.x, mouse.y);\\n        ctx.stroke();\\n        ctx.closePath();\\n      } //Handling the ball collisions\\n\\n\\n      collisionBall(balls[i]);\\n      collisionWall(balls[i]);\\n    } //Rendering Text\\n\\n\\n    ctx.fillStyle = \\'white\\';\\n    ctx.font = \"11pt Ariel\";\\n    ctx.fillText(\"Number of Balls: \" + balls.length, 0, 16);\\n    ctx.fillText(\"Drag Coefficient: \" + drag.value, 0, 32);\\n    ctx.fillText(\"Fluid Density: \" + density.value + \" kg/m^3\", 0, 48);\\n    ctx.fillText(\"Acceleration due to gravity: \" + gravity.value + \" g\", 0, 64);\\n    ctx.fillText(\"Room Width: \" + width / 1000 + \" m\", 0, 80);\\n    ctx.fillText(\"Room Height: \" + height / 1000 + \" m\", 0, 96);\\n  }\\n\\n  function collisionWall(ball) {\\n    if (ball.position.x > width - ball.radius) {\\n      ball.velocity.x *= ball.e;\\n      ball.position.x = width - ball.radius;\\n    }\\n\\n    if (ball.position.y > height - ball.radius) {\\n      ball.velocity.y *= ball.e;\\n      ball.position.y = height - ball.radius;\\n    }\\n\\n    if (ball.position.x < ball.radius) {\\n      ball.velocity.x *= ball.e;\\n      ball.position.x = ball.radius;\\n    }\\n\\n    if (ball.position.y < ball.radius) {\\n      ball.velocity.y *= ball.e;\\n      ball.position.y = ball.radius;\\n    }\\n  }\\n\\n  function collisionBall(b1) {\\n    for (var i = 0; i < balls.length; _readOnlyError(\"i\"), i++) {\\n      var b2 = balls[i];\\n\\n      if (b1.position.x != b2.position.x && b1.position.y != b2.position.y) {\\n        //quick check for potential collisions using AABBs\\n        if (b1.position.x + b1.radius + b2.radius > b2.position.x && b1.position.x < b2.position.x + b1.radius + b2.radius && b1.position.y + b1.radius + b2.radius > b2.position.y && b1.position.y < b2.position.y + b1.radius + b2.radius) {\\n          //pythagoras \\n          var distX = b1.position.x - b2.position.x;\\n          var distY = b1.position.y - b2.position.y;\\n          var d = Math.sqrt(distX * distX + distY * distY); //checking circle vs circle collision \\n\\n          if (d < b1.radius + b2.radius) {\\n            var nx = (b2.position.x - b1.position.x) / d;\\n            var ny = (b2.position.y - b1.position.y) / d;\\n            var p = 2 * (b1.velocity.x * nx + b1.velocity.y * ny - b2.velocity.x * nx - b2.velocity.y * ny) / (b1.mass + b2.mass); // calulating the point of collision \\n\\n            var colPointX = (b1.position.x * b2.radius + b2.position.x * b1.radius) / (b1.radius + b2.radius);\\n            var colPointY = (b1.position.y * b2.radius + b2.position.y * b1.radius) / (b1.radius + b2.radius); //stoping overlap \\n\\n            b1.position.x = colPointX + b1.radius * (b1.position.x - b2.position.x) / d;\\n            b1.position.y = colPointY + b1.radius * (b1.position.y - b2.position.y) / d;\\n            b2.position.x = colPointX + b2.radius * (b2.position.x - b1.position.x) / d;\\n            b2.position.y = colPointY + b2.radius * (b2.position.y - b1.position.y) / d; //updating velocity to reflect collision \\n\\n            b1.velocity.x -= p * b1.mass * nx;\\n            b1.velocity.y -= p * b1.mass * ny;\\n            b2.velocity.x += p * b2.mass * nx;\\n            b2.velocity.y += p * b2.mass * ny;\\n          }\\n        }\\n      }\\n    }\\n  }\\n});\\n\\n//# sourceURL=webpack:///./js/bounce.js?')}});","extractedComments":[]}